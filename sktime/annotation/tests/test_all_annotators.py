"""Tests for sktime annotators."""

__author__ = ["miraep8", "fkiraly", "klam-data", "pyyim", "mgorlin"]
__all__ = []

import numpy as np
import pandas as pd
import pytest

from sktime.tests.test_all_estimators import BaseFixtureGenerator, QuickTester
from sktime.utils._testing.annotation import make_annotation_problem
from sktime.utils.validation.annotation import check_learning_type, check_task


class AnnotatorsFixtureGenerator(BaseFixtureGenerator):
    """Fixture generator for time series annotator (outlier, change point, etc) tests.

    Fixtures parameterized
    ----------------------
    estimator_class: estimator inheriting from BaseObject
        ranges over estimator classes not excluded by EXCLUDE_ESTIMATORS, EXCLUDED_TESTS
    estimator_instance: instance of estimator inheriting from BaseObject
        ranges over estimator classes not excluded by EXCLUDE_ESTIMATORS, EXCLUDED_TESTS
        instances are generated by create_test_instance class method
    scenario: instance of TestScenario
        ranges over all scenarios returned by retrieve_scenarios
    """

    # note: this should be separate from TestAllAnnotators
    #   additional fixtures, parameters, etc should be added here
    #   TestAllAnnotators should contain the tests only

    estimator_type_filter = "series-annotator"

    fixture_sequence = [
        "estimator_class",
        "estimator_instance",
        "fitted_estimator",
        "scenario",
        "method_nsc",
        "method_nsc_arraylike",
    ]

    def _generate_fitted_estimator(self, test_name, **kwargs):
        estimators, estimator_names = self._generate_estimator_instance(
            test_name, **kwargs
        )

        for estimator in estimators:
            X_train = make_annotation_problem(
                n_timepoints=50, estimator_type=estimator.get_tag("distribution_type")
            )
            estimator.fit(X_train)

        return estimators, estimator_names


class TestAllAnnotators(AnnotatorsFixtureGenerator, QuickTester):
    """Module level tests for all sktime annotators."""

    def test_output_type(self, estimator_instance):
        """Test annotator output type."""
        estimator = estimator_instance

        arg = make_annotation_problem(
            n_timepoints=50, estimator_type=estimator.get_tag("distribution_type")
        )
        estimator.fit(arg)
        arg = make_annotation_problem(
            n_timepoints=10, estimator_type=estimator.get_tag("distribution_type")
        )
        y_pred = estimator.predict(arg)
        assert isinstance(y_pred, (pd.Series, np.ndarray))

    def test_transform_output_type(self, fitted_estimator):
        """Test output type for the transform method."""
        arg = make_annotation_problem(
            n_timepoints=10,
            estimator_type=fitted_estimator.get_tag("distribution_type"),
        )
        y_pred = fitted_estimator.transform(arg)
        assert isinstance(y_pred, (pd.Series, np.ndarray))
        assert len(y_pred) == len(arg)

    def test_predict_points(self, fitted_estimator):
        arg = make_annotation_problem(
            n_timepoints=10,
            estimator_type=fitted_estimator.get_tag("distribution_type"),
        )
        y_pred = fitted_estimator.predict_points(arg)
        assert isinstance(y_pred, (pd.Series, np.ndarray))

    def test_predict_segments(self, fitted_estimator):
        arg = make_annotation_problem(
            n_timepoints=10,
            estimator_type=fitted_estimator.get_tag("distribution_type"),
        )
        task = fitted_estimator.get_class_tag("task")
        if task == "anomaly_detection":
            with pytest.raises(RuntimeError):
                fitted_estimator.predict_segments(arg)

        y_pred = fitted_estimator.predict_segments(arg)
        assert isinstance(y_pred, pd.Series)
        assert isinstance(y_pred.index.dtype, pd.IntervalDtype)
        assert pd.api.types.is_integer_dtype(y_pred)

    def test_annotator_tags(self, estimator_class):
        """Check the learning_type and task tags are valid."""
        check_task(estimator_class.get_class_tag("task"))
        check_learning_type(estimator_class.get_class_tag("learning_type"))
